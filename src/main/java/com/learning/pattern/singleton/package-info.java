package com.learning.pattern.singleton;
/**
 * 单例模式是指一个类在任何情况下都绝对只有一个实例，并提供一个全局的访问点
 * 隐藏起构造方法，然后实现线程安全即可。
 * #1.饿汉式
 * 在单例类首次加载时就创建实例
 * 缺点：浪费空间
 * 通过静态变量来实现
 * #2.懒汉式
 * 被外部类调用是才创建实例
 * --1.直接在方法上加synchronized构建单例，容易造成性能问题，在竞争激烈的情况下，会有过多线程的挂起
 * --2.Double-Check形式，只对创建实例时加锁，减少开销，注意使用volatile
 * --3.静态内部类的单例模式，通过jvm实现单例
 * --4.枚举形式的单例模式
 * --5.使用ThreadLocal实现的单例，伪线程安全，在同一个线程中是单例，不同线程还是会创建不同的实例
 * --6.ioc形式，类似spring中ioc创建，通过ConcurrentHashMap
 * 破坏单例的方法：
 * 反射和序列化
 * 注意：枚举形式的单例是无法被破坏的
 * 具体原因：
 * 在反射时，jdk内部会阻止枚举被反射
 * 在序列化时，创建枚举对象是通过类和名称来创建，jvm会保证只有一个对象被创建
 * <p>
 * 反射破坏单例是因为在newInstance时会再次调用构造函数，从而实例化两次，破坏单例
 * 可通过在构造函数中抛出异常方式解决
 * 序列化破坏单例也是一样，也会创建两次对象，可通过readResolve方法来解决
 * 因为在读取流创建对象时如果有该方法会使用该方法来返回对象
 * <p>
 * 优点：
 * 内存中只要一个对象，减少内存开销
 * 缺点：
 * 没有接口，扩展困难，如果要扩展，需修改单例类
 */