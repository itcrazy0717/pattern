/**
 * 设计模式总结
 * 用设计模式能帮助我们更好的解决实际问题
 * 1.spring中用到的设计模式
 * 工厂模式 BeanFactory
 * 装饰器模式 BeanWrapper
 * 代理模式 AopProxy
 * 单例模式 ApplicationContext
 * 委派模式 DispatcherServlet
 * 策略模式 HandlerMapping
 * 适配器模式 HandlerApdapter
 * 模板方法模式 JdbcTemplate
 * 观察者模式 ContextLoaderListener
 * 2.工厂模式
 * 简单工厂模式
 * 由一个工厂对象决定创建出哪一种产品类的实例
 * 属于创建型模式，但它不属于GOF，23种设计模式
 * 在产品相对较少的情况下，简单工厂模式有一定优势，但是当产品较多时，工厂对象的功能就会非常重，违背开闭原则，不利于扩展
 * 涉及角色：工厂对象角色、抽象产品角色、具体产品角色
 * <p>
 * 简单工厂模式
 * 指定一个创建对象的接口，但具体实现延迟到子类中去
 * 只需关心所需产品对应的工厂，无须关心创建细节，加入新的产品符合开闭原则，提高系统的扩展性
 * 但是类的个数容易增多，增加了代码结构的复杂程度
 * 简单工厂只能创建一种产品，因此衍生出抽象工厂模式，可以创建多种产品
 * 涉及角色：抽象工厂角色、具体工厂角色、抽象产品角色、具体产品角色
 * <p>
 * 抽象工厂模式
 * 提供一个创建一系列相关产品的接口，无须指定他们的具体类
 * 可以创建一个相关的产品族，但是如果在产品族中增加一个产品，就需要修改抽象工厂的接口，扩展某类产品容易，在产品族中增加某类产品困难
 * 涉及角色：抽象工厂角色、具体工厂角色、抽象产品角色、具体产品角色
 * <p>
 * 3.单例模式
 * 指一个类在任何情况下都绝对只有一个实例，并提供一个全局的访问点
 * 首先就是隐藏其构造方法（private），然后再考虑线程安全
 * 饿汉式
 * 类首次加载时就创建实例，可保证线程安全，但是有点浪费内存空间，因为不保证是否需要该类，因此该在需要类的时候再进行加载较好
 * 优点：不加锁，绝对线程安全，执行效率高
 * 缺点：类加载时就初始化，不管用或不用都占用空间，内存消耗大
 * 懒汉式
 * 外部调用时再加载实例
 * 懒汉式单例模式有几种
 * #1.直接在获取实例方法上使用synchronized方法的单例
 * 可实现单例，但是在竞争激烈的情况下，造成锁的增强激烈，造成性能影响
 * #2.Double-Check实现单例
 * 将私有变量利用volatile进行修饰保证线程间可见，然后在获取实例方法内部进行加锁，并利用两次判空，第一次判空是为了避免竞争激烈
 * #3.静态内部类单例
 * #4.枚举单例
 * 枚举单例形式可避免反射和序列化破坏单例
 * 枚举的单例，如果通过反编译jad工具查看可知，枚举其实在静态代码块中实现了对枚举值的初始化，其实是饿汉式单例
 * 注册式
 * 类似spring ioc的形式，通过反射实现，然后将类存放在容器中即可
 * ThreadLocal单例
 * 可保证线程内部全局唯一，线程安全，但跨线程就不能保证线程安全了
 * 单例模式保证只有一个实例访问，节约资源，但是没有接口，扩展比较困难
 * <p>
 * 反射是如何破坏单例的
 * 通过反射会调用newInstance方法，相当new多次，生成不同的单例类
 * 解决方式：可在单例的私有构造函数中判断，抛出异常禁止反射形成
 * 通过序列化如何破坏单例
 * 形式一样在readObject的时候也会调用newInstance方法，相当于new了多次，从而破坏单例
 * 注意：readObject方法如果是类会走TC_OBJECT分支，如果是枚举，则会走TC_ENUM分支
 * 解决方式：
 * 重写readResolve返回单例对象即可，因为在readObject方法中会判断是否有该方法存在，如果存在该方法，则使用该方法的返回值
 * 为什么枚举可以防止单例被破坏
 * #1.对于反射：枚举是禁止反射的，从jdk内部进行了阻止
 * #2.对于序列化：在序列化时，枚举是通过Class对象和类名进行的类加载，从而保证jvm中只会存在一个对象
 * <p>
 * 4.原型模式
 * 指定创建对象的种类，通过拷贝这些原型来完成新对象的创建
 * 其实就是对对象进行克隆
 * 适用场景：
 * #1.类初始化消耗资源过多
 * #2.new一个对象需要非常复杂的过程
 * #3.构造函数比较复杂
 * #4.循环体中产生大量对象，可读性下降
 * 涉及角色：抽象原型角色、具体原型角色、client角色
 * 分为浅克隆和深克隆
 * 浅克隆
 * 浅克隆中如果有引用型的属性，克隆对象中的属性与原型对象中引用对象属性的引用地址相同，出现修改会相互影响
 * 深克隆
 * 引用型属性与原型中该属性不是同一个引用地址，两者是完全不同的对象
 * 优点：
 * 性能比直接new一个对象性能高
 * 简化了创建过程
 * <p>
 * 5.代理模式
 * 为其他对象提供一个代理，以控制该对象的访问
 * 代理对象在客户端和目标对象之间起到中介作用
 * 涉及角色：抽象对象角色、具体对象角色、代理角色
 * 代理分：静态代理和动态代理
 * 静态代理：
 * 就是代理类直接持有目标角色的引用，进行代理，在代理量较小的情况下可行，但是一旦代理量增加，就要求代理对象持有过多的引用，并且需修改
 * 代理对象，违背开闭原则
 * 动态代理
 * 动态代理与静态代理思路一致，只是进行了解耦，适应性更强，业务扩展性更强，动态代理在代理之前目标对象不一定存在
 * JDK动态代理 代理对象必须实现InvocationHandler接口
 * 注：JDK动态代理只能代理接口
 * 原理：通过重新生成Proxy对象来实现代理，Proxy对象已经继承了Proxy类，由于Java中不支持多继承，所以这里只能实现接口，也就是为什么JDK动态代理只能代理接口
 * CGLIB动态代理
 * CGLIB代理对象需实现MethodInterceptor接口，通过拦截器去实现代理
 * CBLIB是通过继承目标对象来实现动态代理的
 * 新生成的代理类中都有与源对象相对应的方法
 * 并且会为代理对象和被代理对象生产FastClass文件，在拦截器调用的时候回去该文件中寻找，提高执行的效率，而不是用反射的形式
 * 调用过程：代理对象调用method->调用拦截器->methodProxy.invokeSuper->CGLIB$method$0->被代理对象的实际方法
 * <p>
 * 6.委派模式
 * 负责任务的调度和分配，跟代理模式很像，可以看作是一种特殊情况下的静态代理，但是代理模式注重过程，而委派模式注重结果
 * 涉及角色：抽象任务角色、具体任务角色、委派角色(负责任务的调度与分配)
 * 委派模式其实比较好理解，比如spring-mvc中的DispatcherServlet
 * <p>
 * 7.策略模式
 * 定义算法家族，分别封装起来，让它们直接可以相互替换，但是算法的替换并不会影响到用户的使用
 * 注意这里相互替换的理解：比如对于支付，有支付宝、微信、京东、银联等多种支付，用户在进行支付的时候，可以任意选择一种进行支付，比如先
 * 选了支付宝发现没钱了，又可以选微信
 * 涉及角色：抽象策略角色、具体策略角色、策略调度角色
 * 用策略模式优化if...else，但是有局限，如果if之中存在逻辑关系的话，并不适合利用策略模式进行优化
 * 策略模式符合开闭原则，但客户端必须知道所有的策略
 * 策略模式适用场景：
 * 系统中的多个类，它们的区别只是行为不同
 * <p>
 * 8.模板方法模式
 * 定义一个算法的骨架，允许子类为一个或者多个步骤提供扩展
 * 模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤
 * 涉及角色：抽象模板角色、具体模板角色
 * 优点：提高了代码的复用性、扩展性，符合开闭原则
 * 缺点：增加了类的个数，并且由于继承关系自身的缺点，但父类中增加新的抽象方法后，子类中都要去实现一遍
 * 模板方法模式还是比较好理解的
 * <p>
 * 9.适配器模式
 * 将一个类的接口转换成客户期望的另一个接口，使原本接口不兼容的类可以一起工作
 * 涉及角色：目标角色、抽象适配器角色、具体适配器角色
 * 理解适配器角色比较容易：比如原来电脑使用VGA接口进行的显示，但是由于新的显示屏幕只支持HDMI了，因此需要使用一个VGA转HDMI的转接头进行适配
 * 适配器模式是对已经存在类的一种补丁操作，有点亡羊补牢的感觉
 * <p>
 * 10.装饰模式
 * 指在不改变原有对象的基础上，将功能附加到对象上，提供了比继承更有弹性的替代方案(扩展原有对象的功能)
 * 因为继承自身有缺点，在父类新增了行为后，所有子类都必须修改，违背了开闭原则
 * 涉及角色：抽象构件角色、具体构件角色、装饰角色、具体装饰角色
 * <p>
 * 11.观察者模式
 * 定义了对象一对多的依赖，让多个观察者同时监听一个主题对象，当主题对象发生变化时，观察者都会收到一个更新通知
 * 观察者模式侧重点在变化，主题变化，观察者随即变化
 * 涉及角色：抽象观察者角色、具体观察者角色、抽象主题角色（里面含有观察者角色的引用）、具体主题角色
 * 观察者角色需要注册到主题角色上，这样当主题角色发生改变，就可以使观察者角色发生变化，联想MQ
 */